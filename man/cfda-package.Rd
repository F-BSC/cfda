% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cfda-package.R
\docType{package}
\name{cfda-package}
\alias{cfda-package}
\title{Categorical Functional Data Analysis}
\description{
cfda provides functions for the analysis of categorical functional data. 

The main contribution est the computation of an optimal encoding (real variable) of each state of the categoical data.
This can be done using the \code{\link{compute_optimal_encoding}} function that takes in arguments the data in a specific format and
a basis function created using the \code{fda} package (cf. \code{\link{create.basis}}). The output can be analyzed with \code{\link{plot.fmca}}, 
\code{\link{get_encoding}}, \code{\link{plotEigenvalues}} and \code{\link{plotComponent}}.

\code{\link{plotData}} shows a graphical representation of the dataset. Basic statistics can be computed: the number of jumps (\code{\link{compute_number_jumps}}), the duration (\code{\link{compute_duration}}), 
the time spent in each state (\code{\link{compute_time_spent}}), the probability to be in each state at any given time (\code{\link{estimate_pt}}),
the transition table (\code{\link{statetable}}).

The parameters of a Markov process can be estimated using \code{\link{estimate_Markov}} function.

In order to test the different functions, a real dataset is provided (\code{\link{biofam2}}) as well as two functions for generating data 
(\code{\link{generate_Markov}} and \code{\link{generate_2State}}).
}
\details{
See the vignette for a detailled example and mathematical background:
\code{RShowDoc("cfda", package = "cfda")}
}
\examples{
# simulate the Jukes Cantor models of nucleotides replacement. 
K <- 4
Tmax <- 6
QJK <- matrix(1/3, nrow = K, ncol = K) - diag(rep(1/3, K))
lambda_QJK <- c(1, 1, 1, 1)
d_JK <- generate_Markov_cfd(n = 10, K = K, Q = QJK, lambda = lambda_QJK, Tmax = Tmax)
d_JK2 <- cut_data(d_JK, Tmax)

# create basis object
m <- 10
b <- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding <- compute_optimal_encoding(d_JK2, b, nCores = 1)

# plot eigenvalues
plotEigenvalues(encoding, cumulative = TRUE, normalize = TRUE)

# plot the two first components
plotComponent(encoding, comp = c(1, 2))

# plot the encoding using the first harmonic
plot(encoding)

# extract the encoding using the first harmonic
get_encoding(encoding)


}
\seealso{
\link{compute_optimal_encoding}
}
\keyword{package}
