% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/encoding.R
\name{compute_optimal_encoding}
\alias{compute_optimal_encoding}
\title{Compute the optimal encodings for each state}
\usage{
compute_optimal_encoding(
  data_msm,
  basisobj,
  nCores = max(1, ceiling(detectCores()/2)),
  verbose = TRUE,
  ...
)
}
\arguments{
\item{data_msm}{data.frame containing \code{id}, id of the trajectory, \code{time}, time at which a change occurs and \code{state}, associated state. All individual must end at the same time Tmax (use \code{\link{msm2msmTmax}}).}

\item{basisobj}{basis created using the \code{fda} package.}

\item{nCores}{number of cores used for parallelization. Default is the half of cores.}

\item{verbose}{if TRUE print some information}

\item{...}{parameters for \code{\link{integrate}} function.}
}
\value{
A list containing:
\itemize{
  \item \code{eigenvalues} eigenvalues
  \item \code{alpha} optimal encoding coefficients
  \item \code{pc} principal components
  \item \code{F} matrix containing the \eqn{F_{(x,i)(y,j)}}
  \item \code{V} matrix containing the \eqn{V_{(x,i)}}
  \item \code{G} covariance matrix of \code{V}
  \item \code{basisobj} \code{basisobj} input parameter
}
}
\description{
Compute the optimal encodings for categorical functional data using an extension of the multiple correspondence analysis to a stochastic process.
}
\details{
See the vignette for the mathematical background: \code{RShowDoc("cfda", package = "cfda")}
}
\examples{
# simulate the Jukes Cantor models of nucleotides replacement. 
K <- 4
Tmax <- 6
QJK <- matrix(1/3, nrow = K, ncol = K) - diag(rep(1/3, K))
lambda_QJK <- c(1, 1, 1, 1)
d_JK <- generate_Markov_cfd(n = 10, K = K, Q = QJK, lambda = lambda_QJK, Tmax = Tmax,
                            labels = c("A", "C", "G", "T"))
d_JK2 <- msm2msmTmax(d_JK, Tmax)

# create basis object
m <- 10
b <- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding <- compute_optimal_encoding(d_JK2, b, nCores = 1)

# plot the optimal encoding
plot(encoding)

# plot the two first components
plotComponent(encoding, comp = c(1, 2))

# extract the optimal encoding
get_encoding(encoding, harm = 1)

}
\references{
Deville J.C. (1982) Analyse de donnÃ©es chronologiques qualitatives : comment analyser des calendriers ?, Annales de l'INSEE, No 45, p. 45-104.
}
\seealso{
\link{plot.fmca} \link{plotComponent} \link{get_encoding}
}
\author{
Cristian Preda, Quentin Grimonprez
}
